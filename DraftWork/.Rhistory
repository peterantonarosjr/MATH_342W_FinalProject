#First lets deal with the String columns that have $ symbols and convert to integer
#Extract dollar sign columns as subset to operate on
dollarSymbolSubset = housingData[,.(common_charges,maintenance_cost,parking_charges,sale_price,total_taxes,listing_price_to_nearest_1000)]
#Remove dollar signs based on pattern matching
dollarSymbolSubset[] = lapply(dollarSymbolSubset,gsub,pattern="$",fixed=TRUE,replacement="")
#Also Remove any commas that may appear for large values
dollarSymbolSubset[] = lapply(dollarSymbolSubset,gsub,pattern=",",fixed=TRUE,replacement="")
#Replace the columns in housing Data with the new dollarSymbolSubset
housingData[,c("common_charges","maintenance_cost","parking_charges","sale_price","total_taxes","listing_price_to_nearest_1000"):=
dollarSymbolSubset[,c("common_charges","maintenance_cost","parking_charges","sale_price","total_taxes","listing_price_to_nearest_1000")]]
#Now we need to convert these columns in housing data to integer type
housingData[,c("common_charges","maintenance_cost","parking_charges","sale_price","total_taxes","listing_price_to_nearest_1000")] = lapply(housingData[,c("common_charges","maintenance_cost","parking_charges","sale_price","total_taxes","listing_price_to_nearest_1000")], as.numeric)
########################################################################################
#Second lets deal with changing cats_allowed and dogs_allowed to factors
housingData[,sum(is.na(cats_allowed))] # No NA values for cats_allowed
housingData[,sum(is.na(dogs_allowed))] # No NA values for dogs_allowed
#Changing to factors for cats and dogs allowed
unique(housingData[,cats_allowed]) # 3 "unique" values
#Lets deal with the y instead of a yes
housingData$cats_allowed[grepl("y", housingData$cats_allowed)] = "yes"
length(unique(housingData[,cats_allowed])) # 2 unique values
#Lets do the same for dogs
unique(housingData[,dogs_allowed]) # 3 "unique" values"
housingData$dogs_allowed[grepl("yes89", housingData$dogs_allowed)] = "yes"
length(unique(housingData[,cats_allowed])) # 2 unique values
#Factor them
housingData[,c("cats_allowed","dogs_allowed")] = lapply(housingData[,c("cats_allowed","dogs_allowed")], as.factor)
levels(housingData$cats_allowed) #Check levels
levels(housingData$dogs_allowed) #Check levels
########################################################################################
#Third lets deal with the other String columns that need to be factored (track NA's for later)
housingData[,sum(is.na(coop_condo))] # No NA values for coop_condo
length(unique(housingData[,coop_condo])) # 2 unique values
#Factor it
housingData[,coop_condo := factor(coop_condo)]
levels(housingData$coop_condo)
housingData[,sum(is.na(dining_room_type))] # 448 NA values for dining_room_type
length(unique(housingData[,dining_room_type])) # 6 unique values including NA
length(which(housingData$dining_room_type == "none")) #none occurs 2 times
length(which(housingData$dining_room_type == "dining area")) #dining area occurs 2 times
#Lets deal with the issue of "dining area" as the room type and consider it as type other
housingData$dining_room_type[grepl("dining area", housingData$dining_room_type)] = "other"
length(unique(housingData[,dining_room_type])) # 5 unique values including NA
housingData[,dining_room_type := factor(dining_room_type)]
levels(housingData$dining_room_type)
housingData[,sum(is.na(fuel_type))] # 112 NA values for dining_room_type
length(unique(housingData[,fuel_type])) # 7 "unique" values including NA
#Lets deal with the capitalization issues for fuel_typenone
housingData[,fuel_type := tolower(fuel_type)]
length(unique(housingData[,fuel_type])) # 6 unique values including NA
housingData[,fuel_type := factor(fuel_type)]
levels(housingData$fuel_type)
housingData[,sum(is.na(kitchen_type))]# 16 NA values for dining_room_type
length(unique(housingData[,kitchen_type])) # 14 "unique" values including NA
#Lets deal with the upper case lower case kitchen type differences
housingData[,kitchen_type:=tolower(kitchen_type)] # Lowercase everything to pattern match
length(unique(housingData[,kitchen_type])) # 11 "unique" values including NA
#Lets now deal with spaces creating more unique values
housingData[,kitchen_type := lapply(kitchen_type,gsub,pattern="eat in",fixed=TRUE,replacement="eatin")]
length(unique(housingData[,kitchen_type])) # 10 "unique" values including NA
#Lets lets deal with the misspellings of efficiency kitchen
housingData$kitchen_type[grepl("effic", housingData$kitchen_type)] = "efficiency"
length(unique(housingData[,kitchen_type])) # 6 unique values including NA
#Finally lets deal with 1955 and replace that with NA -> I am assuming here 1955 is wrong and not a type of kitchen
housingData[, kitchen_type := sapply(kitchen_type, function(x) replace(x, which(x=="1955"), NA))]
length(unique(housingData[,kitchen_type])) # t unique values including NA (no 1955 -> NA)
housingData[,kitchen_type := factor(kitchen_type)]
levels(housingData$kitchen_type)
housingData[,sum(is.na(garage_exists))]
length(unique(housingData[,garage_exists])) # 7 "unique" values
#Lets deal with the capitalization and misspelling of yes
housingData[,garage_exists := tolower(garage_exists)]
housingData$garage_exists[grepl("y", housingData$garage_exists)] = "yes"
length(unique(housingData[,garage_exists])) # 5 unique values including NA
#Lets treat underground and ug as yes
housingData$garage_exists[grepl("u", housingData$garage_exists)] = "yes"
length(unique(housingData[,garage_exists])) # 3 unique values including NA
#Lets treat 1 as a yes
housingData$garage_exists[grepl("1", housingData$garage_exists)] = "yes"
length(unique(housingData[,garage_exists])) # 2 unique values including NA
housingData$garage_exists
#Fill NA's in garage with No's -> Use 1s in missingness to indicate this later om.
housingData[, c("garage_exists")][is.na(housingData[, c("garage_exists")])] = "no"
housingData$garage_exists
housingData[,c("garage_exists")] = lapply(housingData[,c("garage_exists")], as.factor)
#setattr(housingData$garage_exists,"levels",c("no","yes"))
#housingData[,garage_exists := factor(garage_exists)]
levels(housingData$garage_exists)
housingData$date_of_sale = format(as.Date(housingData$date_of_sale, format="%m/%d/%Y"),"%m")
housingData[,date_of_sale:= factor(date_of_sale,ordered=FALSE)]
length(unique(housingData[,date_of_sale])) #13 including NA which is what we want
housingData
summary(housingData)
#First lets just add up all the charges into a single column
#Assign new column totalCharges to be the row sum of the chargeCols ignoring NA's
housingData[, totalCharges := rowSums(.SD,na.rm=TRUE), .SDcols = c("common_charges","maintenance_cost","parking_charges","total_taxes")][]
housingData[,sum(is.na(totalCharges))] # No NA's here which is good since
####################################################################################
#Second lets extract the zip codes and assign them to their own column
#Lets use a regular expression to extract the zip code out of this field
housingData[,zip_code := substr(str_extract(full_address_or_zip_code,"[0-9]{5}"),1,5)]
housingData[,zip_code := as.numeric(zip_code)]
#We can now drop the full_address column since we wont need that
housingData[,full_address_or_zip_code := NULL]
####################################################################################
#Third lets add up full and half bathrooms
#Lets divide the half bathroom columns by 2 so that when we add them it is more granular
housingData[,num_half_bathrooms:=num_half_bathrooms/2]
#Assign a new column to represent the total number of bathrooms
housingData[,totalBathrooms :=rowSums(.SD,na.rm=TRUE), .SDcols = c("num_full_bathrooms","num_half_bathrooms")][]
####################################################################################
#Fourth lets bring in some extra data that shows median income by zipcode
queensIncomeDataFilePath = "/home/peterjr/RepoCollections/MATH_342W_FinalProject/Datasets/income_queens_2016.csv"
queensIncomeData = data.table(read.csv(queensIncomeDataFilePath))
#Grab columns we want and remove the first row description of columns
queensIncomeData = queensIncomeData[-1,.(GEO_ID,S1901_C01_012E)]
#Change Data Type
queensIncomeData[,zip_code := as.numeric(GEO_ID)]
#Rename median income column
setnames(queensIncomeData, "S1901_C01_012E", "median_income")
queensIncomeData[,median_income := as.numeric(median_income)]
#Drop the geo_id column
queensIncomeData[,GEO_ID := NULL]
####################################################################################
#Fifth lets join this to our housing data on the zipcode
#We are doing a left join because I want everything in housing preserved -> median income can be imputed
housingData = left_join(housingData,queensIncomeData,by.x = "zip_code",by.y = "zip_code")
housingData[,sum(is.na(median_income))] # 64 NA values, not bad since most are getting filled, should be easy to impute
########################################################################################
#First lets grab the columns that are of interest to us
housingData = housingData[,.(approx_year_built,cats_allowed,community_district_num,coop_condo,date_of_sale,dining_room_type,
dogs_allowed,fuel_type,garage_exists,kitchen_type,num_bedrooms,num_floors_in_building,totalBathrooms,num_total_rooms,
sale_price,sq_footage,walk_score,totalCharges,zip_code,median_income)]
########################################################################################
#Second lets build up our missing table 0/` where 1 indicates a NA value in the original
#Create a missing data table and fill with zeros
colNames = names(housingData)
missRows = nrow(housingData)
missCols = ncol(housingData)
missingData = setNames(data.table(matrix(0,nrow = missRows, ncol = missCols)), colNames)
setnames(missingData,1:ncol(missingData), paste0(names(missingData)[1:ncol(missingData)], '_miss'))
#Data Set with 1s indicating missing in housingData
missingData[is.na(housingData)] = 1
#Let's get a correlation matrix on the numeric only data in our housing data
numericOnlyData = housingData[ , .SD, .SDcols = is.numeric]
ncol(numericOnlyData) # 12 total numeric columns
#We expect there to be at most 12 1 values in the nxn correlation matrix for matching columns
#More than 12 values indicates that there is somewhere else where two different columns are perfectly correlated
correlationMatrix = as.matrix(cor(numericOnlyData))
length(which(correlationMatrix==1)) # 12 matches for perfect correlation, this is okay since it is columns along the diagonal
#Remove missing columns where the sum is 0. Implies housingData did not have any NAs.
#Due to the nature of the construction of the missing table, all columns in housingData have a corresponding *_miss column
#This isn't fully accurate for the original columns without missingness
checkZero= function(x){
if(sum(x)==0){
TRUE
}
}
length(missingData[,sapply(missingData,  checkZero)]) # 7 columns where no missingness, we will drop these
missingData = missingData[, colSums(missingData != 0) > 0, with = FALSE]
########################################################################################
#Lets impute our data set including sale price
imputeSet = housingData
Ximp = missForest(imputeSet,verbose = TRUE)
#Get our final imputed Dataset and bind it to the missiningness table
finalHousingData = cbind(Ximp$ximp,missingData)
#Lets do the same check as in previous for our finalHousingData
numericOnlyData2 = finalHousingData[ , .SD, .SDcols = is.numeric]
ncol(numericOnlyData2) # 25 total numeric columns
#We expect there to be at most 25 1 values in the nxn correlation matrix for matching columns
#More than 25 values indicates that there is somewhere else where two different columns are perfectly correlated
correlationMatrix2 = as.matrix(cor(numericOnlyData2))
length(which(correlationMatrix2==1)) # 27 matches for perfect correlation, no issues here
cor(finalHousingData[,"sale_price_miss"],finalHousingData[,"date_of_sale_miss"]) # These are the 2 perfectly correlated columns
#Let's remove sale_price_miss -> Also it makes sense these two are perfectly correlated, a house with no sale price is not sold therefore no date sold
finalHousingData = finalHousingData[,!("sale_price_miss")]
K=5
test_prop = 1 / K
#Training data (All features)
train_indices = sample(1 : nrow(finalHousingData), round((1 - test_prop) * nrow(finalHousingData)))
train_Data = finalHousingData[train_indices,]
X_train = train_Data[,!c("sale_price")]
y_train = train_Data$sale_price
#Testing data (All features)
test_indices = setdiff(1 : nrow(finalHousingData), train_indices)
test_Data = finalHousingData[test_indices, ]
X_test = test_Data[,!c("sale_price")]
y_test = test_Data$sale_price
lin_mod = lm(y_train~.,X_train,x = TRUE, y = TRUE)
#Getting some general information about the table
summary(housingData)
#Getting some general information about the table
summary(housingData)
#Getting some general information about the table
summary(housingData)
#Getting some general information about the table
summary(housingData)
#Getting some general information about the table
summary(housingData)
#Getting some general information about the table
summary(housingData)
#Getting some general information about the table
summary(housingData)
housingDataFilePath = "/home/peterjr/RepoCollections/MATH_342W_FinalProject/Datasets/housing_data_2016_2017.csv"
housingData = data.table(read.csv(housingDataFilePath))
housingData
housingData
#Getting some general information about the table
summary(housingData)
#Dropping Mturk columns that are not relevant to our housing model
housingData[,c(1:27):=NULL]
#Save the urls for later and remove from data frame (might be useful but not immediately)
housingURLS = housingData[,.(URL)]
#Dropping URL from the data table
housingData[,URL:=NULL]
#Dropping other useless url column from data table (ALL NA's)
housingData[,url:=NULL]
#Dropping model_type because similar information is contained in other columns
housingData[,model_type:=NULL]
housingData
#Getting some general information about the table
summary(housingData)
#Getting some general information about the table
summary(housingData)
#Getting some general information about the table
summary(housingData)
#Getting some general information about the table
summary(housingData)
#Getting some general information about the table
summary(housingData)
#Getting some general information about the table
summary(housingData)
#Getting some general information about the table
summary(housingData)
#Getting some general information about the table
summary(housingData)
summary(housingData)
#Getting some general information about the table
summary(housingData)
#Getting some general information about the table
summary(housingData)
by(housingData, housingData$category, summary)
by(housingData,summary)
library(Hmisc)
pacman::p_install(Hmisc)
library(Hmisc)
Hmisc::describe(data)
Hmisc::describe(housingData)
summary(housingData)
summary(housingData)
summary(housingData)
summary(housingData)
summary(housingData)
summary(housingData)
summary(housingData)
summary(housingData)
summary(housingData)
summary(housingData)
summary(housingData)
knitr::opts_chunk$set(cache = T)
#Memory allocation for Java ~10gb and Garbage Collection
options(java.parameters = c("-XX:+UseConcMarkSweepGC", "-Xmx10000m"))
#Packages to load
pacman::p_load(
ggplot2,
tidyverse,
data.table,
R.utils,
magrittr,
dplyr,
testthat,
YARF,
lubridate,
missForest,
parallel,
doParallel
)
num_of_cores = 8
set_YARF_num_cores(num_of_cores)
library(rJava)
gc()
.jinit()
housingDataFilePath = "/home/peterjr/RepoCollections/MATH_342W_FinalProject/Datasets/housing_data_2016_2017.csv"
housingData = data.table(read.csv(housingDataFilePath))
housingData
#Relevant columns begin at the column labeled (URL)
#Dropping Mturk columns that are not relevant to our housing model
housingData[,c(1:27):=NULL]
#Save the urls for later and remove from data frame (might be useful but not immediately)
housingURLS = housingData[,.(URL)]
#Dropping URL from the data table
housingData[,URL:=NULL]
#Dropping other useless url column from data table (ALL NA's)
housingData[,url:=NULL]
#Dropping model_type because similar information is contained in other columns
housingData[,model_type:=NULL]
housingData
#Getting the column names to write some notes about each column
names(housingData)
#Getting some general information about the table
summary(housingData)
pacman::p_install(Hmisc)
library(Hmisc)
Hmisc::describe(housingData)
summary(housingData)
#Getting some general information about the table
summary(housingData)
ncol(housingData)
knitr::opts_chunk$set(cache = T)
#Memory allocation for Java ~10gb and Garbage Collection
options(java.parameters = c("-XX:+UseConcMarkSweepGC", "-Xmx10000m"))
#Packages to load
pacman::p_load(
ggplot2,
tidyverse,
data.table,
R.utils,
magrittr,
dplyr,
testthat,
YARF,
lubridate,
missForest,
parallel,
doParallel
)
num_of_cores = 8
set_YARF_num_cores(num_of_cores)
library(rJava)
gc()
.jinit()
housingDataFilePath = "/home/peterjr/RepoCollections/MATH_342W_FinalProject/Datasets/housing_data_2016_2017.csv"
housingData = data.table(read.csv(housingDataFilePath))
housingData
#Relevant columns begin at the column labeled (URL)
#Dropping Mturk columns that are not relevant to our housing model
housingData[,c(1:27):=NULL]
#Save the urls for later and remove from data frame (might be useful but not immediately)
housingURLS = housingData[,.(URL)]
#Dropping URL from the data table
housingData[,URL:=NULL]
#Dropping other useless url column from data table (ALL NA's)
housingData[,url:=NULL]
#Dropping model_type because similar information is contained in other columns
housingData[,model_type:=NULL]
housingData
#Getting the column names to write some notes about each column
names(housingData)
#Getting some general information about the table
summary(housingData)
#First lets deal with the String columns that have $ symbols and convert to integer
#Extract dollar sign columns as subset to operate on
dollarSymbolSubset = housingData[,.(common_charges,maintenance_cost,parking_charges,sale_price,total_taxes,listing_price_to_nearest_1000)]
#Remove dollar signs based on pattern matching
dollarSymbolSubset[] = lapply(dollarSymbolSubset,gsub,pattern="$",fixed=TRUE,replacement="")
#Also Remove any commas that may appear for large values
dollarSymbolSubset[] = lapply(dollarSymbolSubset,gsub,pattern=",",fixed=TRUE,replacement="")
#Replace the columns in housing Data with the new dollarSymbolSubset
housingData[,c("common_charges","maintenance_cost","parking_charges","sale_price","total_taxes","listing_price_to_nearest_1000"):=
dollarSymbolSubset[,c("common_charges","maintenance_cost","parking_charges","sale_price","total_taxes","listing_price_to_nearest_1000")]]
#Now we need to convert these columns in housing data to integer type
housingData[,c("common_charges","maintenance_cost","parking_charges","sale_price","total_taxes","listing_price_to_nearest_1000")] = lapply(housingData[,c("common_charges","maintenance_cost","parking_charges","sale_price","total_taxes","listing_price_to_nearest_1000")], as.numeric)
########################################################################################
#Second lets deal with changing cats_allowed and dogs_allowed to factors
housingData[,sum(is.na(cats_allowed))] # No NA values for cats_allowed
housingData[,sum(is.na(dogs_allowed))] # No NA values for dogs_allowed
#Changing to factors for cats and dogs allowed
unique(housingData[,cats_allowed]) # 3 "unique" values
#Lets deal with the y instead of a yes
housingData$cats_allowed[grepl("y", housingData$cats_allowed)] = "yes"
length(unique(housingData[,cats_allowed])) # 2 unique values
#Lets do the same for dogs
unique(housingData[,dogs_allowed]) # 3 "unique" values"
housingData$dogs_allowed[grepl("yes89", housingData$dogs_allowed)] = "yes"
length(unique(housingData[,cats_allowed])) # 2 unique values
#Factor them
housingData[,c("cats_allowed","dogs_allowed")] = lapply(housingData[,c("cats_allowed","dogs_allowed")], as.factor)
levels(housingData$cats_allowed) #Check levels
levels(housingData$dogs_allowed) #Check levels
########################################################################################
#Third lets deal with the other String columns that need to be factored (track NA's for later)
housingData[,sum(is.na(coop_condo))] # No NA values for coop_condo
length(unique(housingData[,coop_condo])) # 2 unique values
#Factor it
housingData[,coop_condo := factor(coop_condo)]
levels(housingData$coop_condo)
housingData[,sum(is.na(dining_room_type))] # 448 NA values for dining_room_type
length(unique(housingData[,dining_room_type])) # 6 unique values including NA
length(which(housingData$dining_room_type == "none")) #none occurs 2 times
length(which(housingData$dining_room_type == "dining area")) #dining area occurs 2 times
#Lets deal with the issue of "dining area" as the room type and consider it as type other
housingData$dining_room_type[grepl("dining area", housingData$dining_room_type)] = "other"
length(unique(housingData[,dining_room_type])) # 5 unique values including NA
housingData[,dining_room_type := factor(dining_room_type)]
levels(housingData$dining_room_type)
housingData[,sum(is.na(fuel_type))] # 112 NA values for dining_room_type
length(unique(housingData[,fuel_type])) # 7 "unique" values including NA
#Lets deal with the capitalization issues for fuel_typenone
housingData[,fuel_type := tolower(fuel_type)]
length(unique(housingData[,fuel_type])) # 6 unique values including NA
housingData[,fuel_type := factor(fuel_type)]
levels(housingData$fuel_type)
housingData[,sum(is.na(kitchen_type))]# 16 NA values for dining_room_type
length(unique(housingData[,kitchen_type])) # 14 "unique" values including NA
#Lets deal with the upper case lower case kitchen type differences
housingData[,kitchen_type:=tolower(kitchen_type)] # Lowercase everything to pattern match
length(unique(housingData[,kitchen_type])) # 11 "unique" values including NA
#Lets now deal with spaces creating more unique values
housingData[,kitchen_type := lapply(kitchen_type,gsub,pattern="eat in",fixed=TRUE,replacement="eatin")]
length(unique(housingData[,kitchen_type])) # 10 "unique" values including NA
#Lets lets deal with the misspellings of efficiency kitchen
housingData$kitchen_type[grepl("effic", housingData$kitchen_type)] = "efficiency"
length(unique(housingData[,kitchen_type])) # 6 unique values including NA
#Finally lets deal with 1955 and replace that with NA -> I am assuming here 1955 is wrong and not a type of kitchen
housingData[, kitchen_type := sapply(kitchen_type, function(x) replace(x, which(x=="1955"), NA))]
length(unique(housingData[,kitchen_type])) # t unique values including NA (no 1955 -> NA)
housingData[,kitchen_type := factor(kitchen_type)]
levels(housingData$kitchen_type)
########################################################################################
#Fourth lets deal with the Garage column (track NA's for later)
housingData[,sum(is.na(garage_exists))] # 1826 NA values for garage exists
length(unique(housingData[,garage_exists])) # 7 "unique" values
#Lets deal with the capitalization and misspelling of yes
housingData[,garage_exists := tolower(garage_exists)]
housingData$garage_exists[grepl("y", housingData$garage_exists)] = "yes"
length(unique(housingData[,garage_exists])) # 5 unique values including NA
#Lets treat underground and ug as yes
housingData$garage_exists[grepl("u", housingData$garage_exists)] = "yes"
length(unique(housingData[,garage_exists])) # 3 unique values including NA
#Lets treat 1 as a yes
housingData$garage_exists[grepl("1", housingData$garage_exists)] = "yes"
length(unique(housingData[,garage_exists])) # 2 unique values including NA
#Fill NA's in garage with No's -> Use 1s in missingness to indicate this later om.
housingData[, c("garage_exists")][is.na(housingData[, c("garage_exists")])] = "no"
housingData[,c("garage_exists")] = lapply(housingData[,c("garage_exists")], as.factor)
#setattr(housingData$garage_exists,"levels",c("no","yes"))
#housingData[,garage_exists := factor(garage_exists)]
levels(housingData$garage_exists)
########################################################################################
#Fifth lets take the date column treat is a an unordered factor
#In order to limit the total number of levels in Date, lets just grabs the months
#We sacrifice some granularity, but hopefully this generalize better
housingData$date_of_sale = format(as.Date(housingData$date_of_sale, format="%m/%d/%Y"),"%m")
housingData[,date_of_sale:= factor(date_of_sale,ordered=FALSE)]
length(unique(housingData[,date_of_sale])) #13 including NA which is what we want
#Lets take a look at our data set now
ncol(housingData)
summary(housingData)
ncol(housingData)
unique(housingData[,garage_exists])
knitr::opts_chunk$set(cache = T)
#Memory allocation for Java ~10gb and Garbage Collection
options(java.parameters = c("-XX:+UseConcMarkSweepGC", "-Xmx10000m"))
#Packages to load
pacman::p_load(
ggplot2,
tidyverse,
data.table,
R.utils,
magrittr,
dplyr,
testthat,
YARF,
lubridate,
missForest,
parallel,
doParallel
)
num_of_cores = 8
set_YARF_num_cores(num_of_cores)
library(rJava)
gc()
.jinit()
housingDataFilePath = "/home/peterjr/RepoCollections/MATH_342W_FinalProject/Datasets/housing_data_2016_2017.csv"
housingData = data.table(read.csv(housingDataFilePath))
housingData
#Relevant columns begin at the column labeled (URL)
#Dropping Mturk columns that are not relevant to our housing model
housingData[,c(1:27):=NULL]
#Save the urls for later and remove from data frame (might be useful but not immediately)
housingURLS = housingData[,.(URL)]
#Dropping URL from the data table
housingData[,URL:=NULL]
#Dropping other useless url column from data table (ALL NA's)
housingData[,url:=NULL]
#Dropping model_type because similar information is contained in other columns
housingData[,model_type:=NULL]
housingData
#Getting the column names to write some notes about each column
names(housingData)
#Getting some general information about the table
summary(housingData)
unique(housingData[,fuel_type])
unique(housingData[,kitchen_type])
unique(housingData[,kitchen_type])
housingData[,sum(is.na(kitchen_type))]# 16 NA values for dining_room_type
length(unique(housingData[,kitchen_type])) # 14 "unique" values including NA
#Lets deal with the upper case lower case kitchen type differences
housingData[,kitchen_type:=tolower(kitchen_type)] # Lowercase everything to pattern match
length(unique(housingData[,kitchen_type])) # 11 "unique" values including NA
#Lets now deal with spaces creating more unique values
housingData[,kitchen_type := lapply(kitchen_type,gsub,pattern="eat in",fixed=TRUE,replacement="eatin")]
length(unique(housingData[,kitchen_type])) # 10 "unique" values including NA
#Lets lets deal with the misspellings of efficiency kitchen
housingData$kitchen_type[grepl("effic", housingData$kitchen_type)] = "efficiency"
length(unique(housingData[,kitchen_type])) # 6 unique values including NA
#Finally lets deal with 1955 and replace that with NA -> I am assuming here 1955 is wrong and not a type of kitchen
housingData[, kitchen_type := sapply(kitchen_type, function(x) replace(x, which(x=="1955"), NA))]
length(unique(housingData[,kitchen_type])) # t unique values including NA (no 1955 -> NA)
housingData[,kitchen_type := factor(kitchen_type)]
levels(housingData$kitchen_type)
levels(housingData$kitchen_type)
