"log(y) ~ ."
)
modeling_task = makeRegrTask(data = Xy_train, target = "y")
modeling_task = makeRegrTask(data = Xy_train, target = "y")
Kouter = 15
outer_loop = makeResampleDesc("CV", iters = Kouter)
install.packages("mlr3").
install.packages("mlr3")
set.seed(1984)
pacman::p_load(tidyverse, magrittr, data.table, ggplot2, lubridate, R.utils, skimr, missForest, qdapRegex)
#install.packages('mlr', repo='http://cran.fiocruz.br/')
#configureMlr(show.info = FALSE, show.learner.output = FALSE, on.learner.warning = "quiet")
if (!pacman::p_isinstalled(YARF)){
pacman::p_install_gh("kapelner/YARF/YARFJARs", ref = "dev")
pacman::p_install_gh("kapelner/YARF/YARF", ref = "dev", force = TRUE)
}
options(java.parameters = "-Xmx4000m")
pacman::p_load(YARF)
PATH_TO_CSV = "/home/peterjr/RepoCollections/MATH_342W_FinalProject/Datasets/housing_data_2016_2017.csv"
housing = fread(PATH_TO_CSV)
colnames(housing)
housing <- housing %>%
select(-HITId, -HITTypeId, -Title, -Description, -Keywords, -Reward, -MaxAssignments, -RequesterAnnotation, -AssignmentDurationInSeconds, -AutoApprovalDelayInSeconds, -NumberOfSimilarHITs, -LifetimeInSeconds, -RejectionTime, -RequesterFeedback, -URL, -url, -WorkTimeInSeconds, -WorkerId, -SubmitTime, -LifetimeApprovalRate, -Last7DaysApprovalRate, -Last30DaysApprovalRate, -Expiration, -CreationTime, -AutoApprovalTime, -AssignmentStatus, -AssignmentId, -ApprovalTime, -AcceptTime)
colnames(housing)
M <- housing %>%
gather(key = "key", value = "val") %>%
mutate(is.missing = is.na(val)) %>%
group_by(key, is.missing) %>%
summarise(num.missing = n()) %>%
filter(is.missing==TRUE) %>%
select(-is.missing) %>%
arrange(desc(num.missing))
M %>% ggplot() +
geom_bar(aes(x=key, y=num.missing), stat = 'identity') +
labs(x='Feature', y = "# Missing Values", title='Number of missing values') +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
coord_flip()
get_zip = function(x) {
pot_zips = unlist(rm_zip(x, extract=TRUE))
return(pot_zips[length(pot_zips)])
}
remove_money_sign = function(x) {
x <- x %>% str_remove("\\$") %>% str_remove(",")
return(x)
}
categorize_zip = function(x) {
category = ""
if (is.element(x, NE)) {
category = "NE"
} else if (is.element(x, N)) {
category = "N"
} else if (is.element(x, C)) {
category = "C"
} else if (is.element(x, J)) {
category = "J"
} else if (is.element(x, NE)) {
category = "NE"
} else if (is.element(x, WC)) {
category = "WC"
} else if (is.element(x, NE)) {
category = "NE"
} else if (is.element(x, WC)) {
category = "WC"
} else if (is.element(x, SE)) {
category = "SE"
} else if (is.element(x, SW)) {
category = "SW"
} else if (is.element(x, W)) {
category = "W"
} else {
return(NA)
}
return(as.factor(category))
}
categorize_kitchen <- function(x) {
if (is.na(x)) {
return(NA)
}
category = ""
if (x == "eat in" | x == "eatin" | x == "Eat In" | x == "Eat in") {
category = "EI"
} else if ( x == "efficiency" | x == "efficiency kitchene" | x == "efficiency kitchen" | x == "efficiemcy" | x == "efficiency ktchen") {
category = "EF"
} else if (x == "Combo" | x == "combo") {
category = "C"
} else {
return(NA)
}
return(as.factor(category))
}
NE = c(11361, 11362, 11363, 11364)
N = c(11354, 11355, 11356, 11357, 11358, 11359, 11360)
C = c(11365, 11366, 11367)
J = c(11412, 11423, 11432, 11433, 11434, 11435, 11436)
NW = c(11101, 11102, 11103, 11104, 11105, 11106)
WC = c(11374, 11375, 11379, 11385)
SE = c(11004, 11005, 11411, 11413, 11422, 11426, 11427, 11428, 11429)
SW = c(11414, 11415, 11416, 11417, 11418, 11419, 11420, 11421)
W = c(11368, 11369, 11370, 11372, 11373, 11377, 11378)
housing <- housing %>%
rowwise() %>%
mutate(zip = categorize_zip(as.numeric(get_zip(full_address_or_zip_code))))
housing <- housing %>%
select(-model_type, -full_address_or_zip_code)
housing <- housing %>%
mutate(common_charges = as.numeric(remove_money_sign(common_charges)),
maintenance_cost = as.numeric(remove_money_sign(maintenance_cost)),
parking_charges = as.numeric(remove_money_sign(parking_charges)),
sale_price = as.numeric(remove_money_sign(sale_price)),
total_taxes = as.numeric(remove_money_sign(total_taxes))) %>%
select(-listing_price_to_nearest_1000)
housing = housing %>% rowwise() %>% mutate(all_charges = sum(total_taxes,parking_charges, maintenance_cost,common_charges,na.rm=TRUE))
housing = select(housing, -c(total_taxes,parking_charges,maintenance_cost,common_charges))
housing
housing %>% ggplot() +
geom_point(aes(x = sale_price, y = sq_footage)) +
labs(x = "Sale Price", y = "Square Footage", title='Square Feet vs. Sale Price') +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
housing <- housing %>%
mutate(cats_allowed = as.factor(ifelse(cats_allowed == "yes" | cats_allowed == "y", 1, 0)),
dogs_allowed = as.factor(ifelse(dogs_allowed == "yes" | dogs_allowed == "y", 1, 0)))
housing %>%
ggplot() +
geom_histogram(aes(x = cats_allowed), stat = "count") +
labs(x = 'Cats Allowed', y = "Count", title='Cats Allowed') +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
housing %>%
ggplot() +
geom_histogram(aes(x = dogs_allowed), stat = "count", position = position_dodge(0.8)) +
labs(x = 'Dogs Allowed', y = "Count", title='Dogs Allowed') +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
housing <- housing %>%
mutate(coop_condo = as.factor(coop_condo))
housing <- housing %>%
mutate(dining_room_type = as.factor(ifelse(dining_room_type == "dining area" | dining_room_type == "none", "other", dining_room_type)))
housing %>%
ggplot() +
geom_histogram(aes(x = dining_room_type), stat = "count") +
labs(x = 'Dining Room Type', y = "Count", title = 'Dining Room Type') +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
housing %>%
ggplot() +
geom_histogram(aes(x = garage_exists), stat = "count") +
labs(x = 'Garage Exists', y = "Count", title = 'garage Exists') +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
housing <- housing %>%
select(-garage_exists)
housing %>%
ggplot() +
geom_histogram(aes(x = fuel_type), stat = "count") +
labs(x = 'Fuel Type', y = "Count", title = 'Fuel Type') +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
housing <- housing %>%
mutate(fuel_type = as.factor(ifelse(fuel_type == "gas" | fuel_type == "oil", fuel_type, "other")))
housing %>%
ggplot() +
geom_histogram(aes(x = fuel_type), stat = "count") +
labs(x = 'Fuel Type', y = "Count", title = 'Fuel Type') +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
housing <- housing %>%
mutate(date_of_sale = as.numeric(as.POSIXct(date_of_sale, format="%m/%d/%Y")))
housing %>%
ggplot() +
geom_histogram(aes(x = kitchen_type), stat = "count") +
labs(x = 'Kitchen Type', y = "Count", title = 'Kitchen Type') +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
housing <- housing %>%
rowwise() %>%
mutate(kitchen_type = categorize_kitchen(kitchen_type)) %>%
select(-kitchen_type)
housing %>%
ggplot() +
geom_histogram(aes(x = as.factor(num_bedrooms)), stat = "count") +
labs(x = 'Number Of Bedrooms', y = "Count", title = 'Number of Bedrooms')
housing <- housing %>%
mutate(num_bedrooms = as.integer(num_bedrooms))
housing <- housing %>%
mutate(num_floors_in_building = as.integer(num_floors_in_building))
housing
housing = housing %>% rowwise() %>% mutate(all_bathrooms = sum(num_full_bathrooms ,num_half_bathrooms,na.rm=TRUE))
housing = select(housing, -c(num_full_bathrooms ,num_half_bathrooms))
housing
housing <- housing  %>%
select(-community_district_num)
housing <- housing %>%
mutate(num_total_rooms = as.integer(num_total_rooms), num_floors_in_building = as.integer(num_floors_in_building), num_bedrooms = as.integer(num_bedrooms))
housing
y <- housing$sale_price
X <- housing %>% select(-sale_price)
M = as_tibble(apply(is.na(X), 2, as.numeric))
colnames(M) = paste("is_missing_", colnames(X), sep = "")
M %<>%
select_if(function(x){sum(x) > 0})
skim(M)
M = tbl_df(t(unique(t(M))))
skim(M)
Ximp = missForest(data.frame(X), sampsize = rep(350, ncol(X)))$ximp
X_new = data.frame(Ximp, y) %>% drop_na()
X = X_new %>% select(-y)
y = X_new$y
n = nrow(X)
K = 5
test_indices = sample(1 : n, 1  / K * n)
train_indices = setdiff(1 : n, test_indices)
X_train = X[train_indices, ]
y_train = y[train_indices]
X_test = X[test_indices, ]
y_test = y[test_indices]
dim(X_train)
dim(X_test)
length(y_train)
length(y_test)
summary(X_new)
vanilla_ols = lm(y_train ~ ., X_train)
y_hat_train = predict(vanilla_ols, X_train)
e_train = y_train - y_hat_train
SSE = t(e_train) %*% e_train
MSE = 1 / (nrow(X_train) - ncol(X_train)) * SSE
RMSE = sqrt(MSE)
SSE
MSE
RMSE
s_sq_y = var(y_train)
n = length(e_train)
SST = (n - 1) * s_sq_y
Rsq = 1 - SSE / SST
Rsq
y_hat = predict(vanilla_ols, X_test)
e = y_test - y_hat
SSE = t(e) %*% e
MSE = 1 / (nrow(X_test) - ncol(X_test)) * SSE
RMSE = sqrt(MSE)
SSE
MSE
RMSE
s_sq_y = var(y_test)
n = length(e)
SST = (n - 1) * s_sq_y
Rsq = 1 - SSE / SST
Rsq
vanilla_ols$coefficients
summary(vanilla_ols)
Xy_train = data.frame(X_new)
all_model_formulas = list(
"y ~ .",
"y ~ . * .",
"log(y) ~ ."
)
modeling_task = makeRegrTask(data = Xy_train, target = "y")
#install.packages('mlr', repo='http://cran.fiocruz.br/')
configureMlr(show.info = FALSE, show.learner.output = FALSE, on.learner.warning = "quiet")
library(mlr3)
pacman::p_load(tidyverse, magrittr, data.table, ggplot2, lubridate, R.utils, skimr, missForest, mlr,qdapRegex)
set.seed(1984)
pacman::p_load(tidyverse, magrittr, data.table, ggplot2, lubridate, R.utils, skimr, missForest, mlr3,qdapRegex)
#install.packages('mlr', repo='http://cran.fiocruz.br/')
configureMlr(show.info = FALSE, show.learner.output = FALSE, on.learner.warning = "quiet")
#install.packages('mlr', repo='http://cran.fiocruz.br/')
configureMlr(show.info = FALSE, show.learner.output = FALSE, on.learner.warning = "quiet")
pacman::p_load(tidyverse, magrittr, data.table, ggplot2, lubridate, R.utils, skimr, missForest, mlr3 ,qdapRegex)
#Set cache for seed
knitr::opts_chunk$set(cache = T)
#Memory allocation for Java ~10gb and Garbage Collection
options(java.parameters = c("-XX:+UseConcMarkSweepGC", "-Xmx10000m"))
#Packages to load
pacman::p_load(
ggplot2,
tidyverse,
data.table,
R.utils,
magrittr,
dplyr,
testthat,
YARF,
lubridate,
missForest,
parallel,
doParallel,
caret,
glmnet
)
#Set CPU cores for YARF
num_of_cores = 8
set_YARF_num_cores(num_of_cores)
#Initialize rJava
library(rJava)
gc()
.jinit()
#Set our file path & read in file
housingDataFilePath = "/home/peterjr/RepoCollections/MATH_342W_FinalProject/Datasets/housing_data_2016_2017.csv"
#Keep a unaltered "True" copy
housingDataTrue = data.table(fread(housingDataFilePath))
housingData = housingDataTrue
housingData
#Relevant columns begin at the column labeled (URL)
#Dropping Mturk columns that are not relevant to our housing model
housingData[,c(1:27):=NULL]
#Save the urls in case they are needed
housingURLS = housingData[,.(URL)]
#Dropping URL from the data table
housingData[,URL:=NULL]
#Dropping other useless url column from data table (ALL NA's)
housingData[,url:=NULL]
#Dropping model_type because similar information is contained in other columns
housingData[,model_type:=NULL]
housingData
#Getting the column names to write some notes about each column
names(housingData)
#Getting some general information about the table
summary(housingData)
#First lets deal with the String columns that have $ symbols and convert to integer
#Extract dollar sign columns as subset to operate on
dollarSymbolSubset = housingData[,.(common_charges,maintenance_cost,parking_charges,sale_price,total_taxes,listing_price_to_nearest_1000)]
#Remove dollar signs based on pattern matching
dollarSymbolSubset[] = lapply(dollarSymbolSubset,gsub,pattern="$",fixed=TRUE,replacement="")
#Also Remove any commas that may appear for large values
dollarSymbolSubset[] = lapply(dollarSymbolSubset,gsub,pattern=",",fixed=TRUE,replacement="")
#Replace the columns in housing Data with the new dollarSymbolSubset
housingData[,c("common_charges","maintenance_cost","parking_charges","sale_price","total_taxes","listing_price_to_nearest_1000"):=
dollarSymbolSubset[,c("common_charges","maintenance_cost","parking_charges","sale_price","total_taxes","listing_price_to_nearest_1000")]]
#Now we need to convert these columns in housing data to integer type
housingData[,c("common_charges","maintenance_cost","parking_charges","sale_price","total_taxes","listing_price_to_nearest_1000")] = lapply(housingData[,c("common_charges","maintenance_cost","parking_charges","sale_price","total_taxes","listing_price_to_nearest_1000")], as.numeric)
#########################################################################
#Second lets deal with changing cats_allowed and dogs_allowed to factors
housingData[,sum(is.na(cats_allowed))] # No NA values for cats_allowed
housingData[,sum(is.na(dogs_allowed))] # No NA values for dogs_allowed
#Changing to factors for cats and dogs allowed
unique(housingData[,cats_allowed]) # 3 "unique" values
#Lets deal with the y instead of a yes
housingData$cats_allowed[grepl("y", housingData$cats_allowed)] = "yes"
length(unique(housingData[,cats_allowed])) # 2 unique values
#Lets do the same for dogs
unique(housingData[,dogs_allowed]) # 3 "unique" values"
housingData$dogs_allowed[grepl("yes89", housingData$dogs_allowed)] = "yes"
length(unique(housingData[,cats_allowed])) # 2 unique values
#Factor them
housingData[,c("cats_allowed","dogs_allowed")] = lapply(housingData[,c("cats_allowed","dogs_allowed")], as.factor)
levels(housingData$cats_allowed) #Check levels
levels(housingData$dogs_allowed) #Check levels
############################################################################
#Third lets deal with other String columns to be factored (track NA's for later)
housingData[,sum(is.na(coop_condo))] # No NA values for coop_condo
length(unique(housingData[,coop_condo])) # 2 unique values
#Factor it
housingData[,coop_condo := factor(coop_condo)]
levels(housingData$coop_condo)
housingData[,sum(is.na(dining_room_type))] # 448 NA values for dining_room_type
length(unique(housingData[,dining_room_type])) # 6 unique values including NA
length(which(housingData$dining_room_type == "none")) #none occurs 2 times
length(which(housingData$dining_room_type == "dining area")) #dining area occurs 2 times
#Lets deal with the issue of "dining area" as the room type and consider it as type other
housingData$dining_room_type[grepl("dining area", housingData$dining_room_type)] = "other"
length(unique(housingData[,dining_room_type])) # 5 unique values including NA
housingData[,dining_room_type := factor(dining_room_type)]
levels(housingData$dining_room_type)
housingData[,sum(is.na(fuel_type))] # 112 NA values for dining_room_type
length(unique(housingData[,fuel_type])) # 7 "unique" values including NA
#Lets deal with the capitalization issues for fuel_typenone
housingData[,fuel_type := tolower(fuel_type)]
housingData$fuel_type[grepl("none", housingData$fuel_type)] = "other"
length(unique(housingData[,fuel_type])) # r unique values including NA
housingData[,fuel_type := factor(fuel_type)]
levels(housingData$fuel_type)
housingData[,sum(is.na(kitchen_type))]# 16 NA values for dining_room_type
length(unique(housingData[,kitchen_type])) # 14 "unique" values including NA
#Lets deal with the upper case lower case kitchen type differences
housingData[,kitchen_type:=tolower(kitchen_type)] # Lowercase everything to pattern match
length(unique(housingData[,kitchen_type])) # 11 "unique" values including NA
#Lets now deal with spaces creating more unique values
housingData[,kitchen_type := lapply(kitchen_type,gsub,pattern="eat in",fixed=TRUE,replacement="eatin")]
length(unique(housingData[,kitchen_type])) # 10 "unique" values including NA
#Lets lets deal with the misspellings of efficiency kitchen
housingData$kitchen_type[grepl("effic", housingData$kitchen_type)] = "efficiency"
length(unique(housingData[,kitchen_type])) # 6 unique values including NA
#Finally lets deal with 1955 and replace that with NA -> I am assuming here 1955 is wrong and not a type of kitchen
housingData[, kitchen_type := sapply(kitchen_type, function(x) replace(x, which(x=="1955"), NA))]
length(unique(housingData[,kitchen_type])) # t unique values including NA (no 1955 -> NA)
housingData[,kitchen_type := factor(kitchen_type)]
levels(housingData$kitchen_type)
###########################################################################
#Fourth lets deal with the Garage column (track NA's for later)
housingData[,sum(is.na(garage_exists))] # 1826 NA values for garage exists
length(unique(housingData[,garage_exists])) # 7 "unique" values
#Lets deal with the capitalization and misspelling of yes
housingData[,garage_exists := tolower(garage_exists)]
housingData$garage_exists[grepl("y", housingData$garage_exists)] = "yes"
length(unique(housingData[,garage_exists])) # 5 unique values including NA
#Lets treat underground and ug as yes
housingData$garage_exists[grepl("u", housingData$garage_exists)] = "yes"
length(unique(housingData[,garage_exists])) # 3 unique values including NA
#Lets treat 1 as a yes
housingData$garage_exists[grepl("1", housingData$garage_exists)] = "yes"
length(unique(housingData[,garage_exists])) # 2 unique values including NA
#Fill NA's in garage with No's -> Use 1s in missingness to indicate this later om.
housingData[, c("garage_exists")][is.na(housingData[, c("garage_exists")])] = "no"
housingData[,c("garage_exists")] = lapply(housingData[,c("garage_exists")], as.factor)
#setattr(housingData$garage_exists,"levels",c("no","yes"))
#housingData[,garage_exists := factor(garage_exists)]
levels(housingData$garage_exists)
###########################################################################
#Fifth lets take the date column treat is a an unordered factor
#In order to limit the total number of levels in Date, lets just grabs the months
#We sacrifice some granularity, but hopefully this generalize better
housingData$date_of_sale = format(as.Date(housingData$date_of_sale, format="%m/%d/%Y"),"%m")
housingData[,date_of_sale:= factor(date_of_sale,ordered=FALSE)]
length(unique(housingData[,date_of_sale])) #13 including NA which is what we want
#Lets take a look at our data set now
ncol(housingData)
summary(housingData)
length(unique(housingData[,dining_room_type]))
unique(housingData[,dining_room_type])
#First lets deal with the String columns that have $ symbols and convert to integer
#Extract dollar sign columns as subset to operate on
dollarSymbolSubset = housingData[,.(common_charges,maintenance_cost,parking_charges,sale_price,total_taxes,listing_price_to_nearest_1000)]
#Remove dollar signs based on pattern matching
dollarSymbolSubset[] = lapply(dollarSymbolSubset,gsub,pattern="$",fixed=TRUE,replacement="")
#Also Remove any commas that may appear for large values
dollarSymbolSubset[] = lapply(dollarSymbolSubset,gsub,pattern=",",fixed=TRUE,replacement="")
#Replace the columns in housing Data with the new dollarSymbolSubset
housingData[,c("common_charges","maintenance_cost","parking_charges","sale_price","total_taxes","listing_price_to_nearest_1000"):=
dollarSymbolSubset[,c("common_charges","maintenance_cost","parking_charges","sale_price","total_taxes","listing_price_to_nearest_1000")]]
#Now we need to convert these columns in housing data to integer type
housingData[,c("common_charges","maintenance_cost","parking_charges","sale_price","total_taxes","listing_price_to_nearest_1000")] = lapply(housingData[,c("common_charges","maintenance_cost","parking_charges","sale_price","total_taxes","listing_price_to_nearest_1000")], as.numeric)
#########################################################################
#Second lets deal with changing cats_allowed and dogs_allowed to factors
housingData[,sum(is.na(cats_allowed))] # No NA values for cats_allowed
housingData[,sum(is.na(dogs_allowed))] # No NA values for dogs_allowed
#Changing to factors for cats and dogs allowed
unique(housingData[,cats_allowed]) # 3 "unique" values
#Lets deal with the y instead of a yes
housingData$cats_allowed[grepl("y", housingData$cats_allowed)] = "yes"
length(unique(housingData[,cats_allowed])) # 2 unique values
#Lets do the same for dogs
unique(housingData[,dogs_allowed]) # 3 "unique" values"
housingData$dogs_allowed[grepl("yes89", housingData$dogs_allowed)] = "yes"
length(unique(housingData[,cats_allowed])) # 2 unique values
#Factor them
housingData[,c("cats_allowed","dogs_allowed")] = lapply(housingData[,c("cats_allowed","dogs_allowed")], as.factor)
levels(housingData$cats_allowed) #Check levels
levels(housingData$dogs_allowed) #Check levels
############################################################################
#Third lets deal with other String columns to be factored (track NA's for later)
housingData[,sum(is.na(coop_condo))] # No NA values for coop_condo
length(unique(housingData[,coop_condo])) # 2 unique values
#Factor it
housingData[,coop_condo := factor(coop_condo)]
levels(housingData$coop_condo)
housingData[,sum(is.na(dining_room_type))] # 448 NA values for dining_room_type
length(unique(housingData[,dining_room_type])) # 6 unique values including NA
length(which(housingData$dining_room_type == "none")) #none occurs 2 times
length(which(housingData$dining_room_type == "dining area")) #dining area occurs 2 times
#Lets deal with the issue of "dining area" as the room type and consider it as type other
housingData$dining_room_type[grepl("dining area", housingData$dining_room_type)] = "other"
housingData$dining_room_type[grepl("none", housingData$dining_room_type)] = "other"
length(unique(housingData[,dining_room_type])) # 5 unique values including NA
housingData[,dining_room_type := factor(dining_room_type)]
levels(housingData$dining_room_type)
housingData[,sum(is.na(fuel_type))] # 112 NA values for dining_room_type
length(unique(housingData[,fuel_type])) # 7 "unique" values including NA
#Lets deal with the capitalization issues for fuel_typenone
housingData[,fuel_type := tolower(fuel_type)]
housingData$fuel_type[grepl("none", housingData$fuel_type)] = "other"
length(unique(housingData[,fuel_type])) # r unique values including NA
housingData[,fuel_type := factor(fuel_type)]
levels(housingData$fuel_type)
housingData[,sum(is.na(kitchen_type))]# 16 NA values for dining_room_type
length(unique(housingData[,kitchen_type])) # 14 "unique" values including NA
#Lets deal with the upper case lower case kitchen type differences
housingData[,kitchen_type:=tolower(kitchen_type)] # Lowercase everything to pattern match
length(unique(housingData[,kitchen_type])) # 11 "unique" values including NA
#Lets now deal with spaces creating more unique values
housingData[,kitchen_type := lapply(kitchen_type,gsub,pattern="eat in",fixed=TRUE,replacement="eatin")]
length(unique(housingData[,kitchen_type])) # 10 "unique" values including NA
#Lets lets deal with the misspellings of efficiency kitchen
housingData$kitchen_type[grepl("effic", housingData$kitchen_type)] = "efficiency"
length(unique(housingData[,kitchen_type])) # 6 unique values including NA
#Finally lets deal with 1955 and replace that with NA -> I am assuming here 1955 is wrong and not a type of kitchen
housingData[, kitchen_type := sapply(kitchen_type, function(x) replace(x, which(x=="1955"), NA))]
length(unique(housingData[,kitchen_type])) # t unique values including NA (no 1955 -> NA)
housingData[,kitchen_type := factor(kitchen_type)]
levels(housingData$kitchen_type)
###########################################################################
#Fourth lets deal with the Garage column (track NA's for later)
housingData[,sum(is.na(garage_exists))] # 1826 NA values for garage exists
length(unique(housingData[,garage_exists])) # 7 "unique" values
#Lets deal with the capitalization and misspelling of yes
housingData[,garage_exists := tolower(garage_exists)]
housingData$garage_exists[grepl("y", housingData$garage_exists)] = "yes"
length(unique(housingData[,garage_exists])) # 5 unique values including NA
#Lets treat underground and ug as yes
housingData$garage_exists[grepl("u", housingData$garage_exists)] = "yes"
length(unique(housingData[,garage_exists])) # 3 unique values including NA
#Lets treat 1 as a yes
housingData$garage_exists[grepl("1", housingData$garage_exists)] = "yes"
length(unique(housingData[,garage_exists])) # 2 unique values including NA
#Fill NA's in garage with No's -> Use 1s in missingness to indicate this later om.
housingData[, c("garage_exists")][is.na(housingData[, c("garage_exists")])] = "no"
housingData[,c("garage_exists")] = lapply(housingData[,c("garage_exists")], as.factor)
#setattr(housingData$garage_exists,"levels",c("no","yes"))
#housingData[,garage_exists := factor(garage_exists)]
levels(housingData$garage_exists)
###########################################################################
#Fifth lets take the date column treat is a an unordered factor
#In order to limit the total number of levels in Date, lets just grabs the months
#We sacrifice some granularity, but hopefully this generalize better
housingData$date_of_sale = format(as.Date(housingData$date_of_sale, format="%m/%d/%Y"),"%m")
housingData[,date_of_sale:= factor(date_of_sale,ordered=FALSE)]
length(unique(housingData[,date_of_sale])) #13 including NA which is what we want
#Lets take a look at our data set now
ncol(housingData)
summary(housingData)
length(unique(housingData[,dining_room_type]))
